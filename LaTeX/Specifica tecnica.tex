%Document-Author: Bonato Paolo + Biggeri Mattia
%Document-Date: 2016/03/24
%Document-Description: Documento di Specifica tecnica del gruppo SWEeneyThreads 

\documentclass[a4paper]{article}
\usepackage[english, italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{eurosym}
\usepackage{tabularx}
\usepackage{pifont}
\usepackage[table]{xcolor}
\usepackage{float}
\usepackage[]{appendix}
\usepackage{ltxtable} 
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{longtable}
\usepackage{multirow}

\graphicspath{{Immagini/}}

\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcolumntype{s}{>{\hsize=.21\hsize}X}
\newcolumntype{f}{>{\hsize=.37\hsize}X}
\newcolumntype{m}{>{\hsize=.42\hsize}X}
\newcolumntype{t}{>{\hsize=.1\hsize}X}
\newcolumntype{r}{>{\hsize=.3\hsize}X}
\newcolumntype{k}{>{\hsize=.4\hsize}X}

\renewcommand{\abstractname}{Tabella contenuti}

\begin{document}
	
	\begin{titlepage}
		% Defines a new command for the horizontal lines, change thickness here
		\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
		\center  
		
		% HEADING SECTION
		\textsc{\LARGE SWEeneyThreads}\\[1.5cm] 
		\textsc{\Large Actorbase}\\[0.5cm] 
		\textsc{\large a NoSQL DB based on the Actor model}\\[0.5cm]
		
		
		% TITLE SECTION
		\HRule \\[0.4cm]
		{ \huge \bfseries Specifica Tecnica}\\[0.4cm] 
		\HRule \\[1.5cm]
		
		% AUTHOR SECTION
		\begin{minipage}{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Redattori:}\\
				Bonato Paolo \\
				Bortolazzo Matteo \\
				Biggeri Mattia \\
				Maino Elia \\
				Nicoletti Luca  \\
				Padovan Tommaso \\
				Tommasin Davide
			\end{flushleft}
		\end{minipage}
		~
		\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
				\emph{Approvazione:} \\
				\emph{Verifica:} \\
				 
			\end{flushright}
		\end{minipage}
		
		%immagine
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.8]{sweeney.png}
		\end{figure}
		\begin{center}
			Versione 0.0.6
		\end{center}
		% Date, change the \today to a set date if you want to be precise
		{\large \today}\\[3cm] 
		% Fill the rest of the page with whitespace
		\vfill  
	\end{titlepage}
	
	
	\tableofcontents
	
	\newpage 
	\section*{Diario delle modifiche}
		\begin{table}[H]
			\begin{tabularx}{\textwidth}{s f m X}
				\noalign{\hrule height 1.5pt}
				\rowcolor{orange!85} Versione & Data & Autore & Descrizione \\
				\noalign{\hrule height 0.5pt}
				0.0.6 & 2016-04-09 & \emph{Progettisti} \newline Biggeri Mattia \newline Padovan Tommaso \newline Bonato Paolo & Stesura sezioni Driver, Diagrammi attività, Stime di fattibilità e bisogno di risorse;  aggiunta immagine nella sezione 3.2.3, aggiunto Singleton nelle descrizioni dei desing pattern, aggiornata leggenda.     \\
				\noalign{\hrule height 0.5pt}
				0.0.5 & 2016-04-08 & \emph{Progettisti} \newline Maino Elia \newline Nicoletti Luca \newline Bortolazzo Matteo & Stesura sezione riguardante le componenti dell'architettura lato server: diagrammi dei package e delle classi e descrizioni testuali   \\
				\noalign{\hrule height 0.5pt}
				0.0.4 & 2016-04-06 & \emph{Progettisti} \newline Biggeri Mattia \newline Tommasin Davide & Aggiunta sezione in appendice suoi Desing Pattern, contiene al momento la descrizione di: MVC, Event-driven, Command   \\
				\noalign{\hrule height 0.5pt}
				0.0.3 & 2016-04-03 & \emph{Progettista} \newline Bonato Paolo & Accorpate le sezioni "Componenti", "Package" e "Classi" in "Componenti e classi". Riadattata la sezione "Metodo e formalismo di specifica" alla nuova struttura. Inserite le immagini 1 e 2. Apportate le correzioni indicate. \\
                \noalign{\hrule height 0.5pt}
				0.0.2 & 2016-03-26 & \emph{Progettisti} \newline Bonato Paolo \newline Biggeri Mattia \newline Padovan Tommaso \newline Tommasin Davide \newline Bortolazzo Matteo & Prima stesura di Architettura generale (sezinoe 3) e componenti (sezione 4)\\
				\noalign{\hrule height 0.5pt}
				0.0.1 & 2016-03-24 & \emph{Analisti} \newline Bonato Paolo \newline Biggeri Mattia & Creazione scheletro documento, stesura introduzione, definizione di metodo e formalismo di specifica. \\
				\noalign{\hrule height 1.5pt}
			\end{tabularx}
			\caption{Diario delle modifiche \label{tab:table_label}}
		\end{table}
	



	\newpage \section{Introduzione}
	\subsection{Scopo del documento}
		Il documento definisce la progettazione ad alto livello del progetto Actorbase.
		Verrà presentata l'architettura generale, le componenti, le classi e i design pattern utilizzati per realizzare il prodotto.
	\subsection{Scopo del prodotto}
		Il progetto consiste nella realizzazione di un DataBase NoSQL key-value basato sul modello ad 
		Attori con l'obiettivo di fornire una tecnologia adatta allo sviluppo di moderne 
		applicazioni che richiedono brevissimi tempi di risposta e che elaborano enormi quantità 
		di dati. Lo sviluppo porterà al rilascio del software sotto licenza MIT.
	\subsection{Glossario}
		Al fine di evitare ambiguità di linguaggio e di massimizzare la comprensione dei documenti, il 
      gruppo ha steso un documento interno che è il \emph{Glossario v1.3.0}. In esso saranno definiti, in modo
      chiaro e conciso i termini che possono causare ambiguità o incomprensione del testo.
	\subsection{Riferimenti}
		\begin{itemize}
			\item \textbf{Slide dell'insegnamento Ingegneria del software mod.A:} \\
			\url{http://www.math.unipd.it/~tullio/IS-1/2015/Dispense/E02.pdf}
			\item \textbf{Scala:} \\
			\url{http://www.scala-lang.org/}
			\item \textbf{Java:} \\
			\url{http://www.java.com/}
			\item \textbf{Akka:} \\
			\url{http://akka.io/}
			\item \textbf{InelliJ:} \\
			\url{http://www.jetbrains.com/idea/}
		\end{itemize}
	\subsubsection{Normativi}
		\begin{itemize}
			\item \textbf{Norme di progetto:} \emph{Norme di progetto v1.3.3}
			\item \textbf{Capitolato d'appalto Actorbase (C1):} \\ 
			\url{http://www.math.unipd.it/~tullio/IS-1/2015/Progetto/C1p.pdf}
		\end{itemize}
		
		
	\newpage 
	\section{Tecnologie utilizzate}
	\subsection{Scala}
		Le possibili scelte dettate dal capitolato sono Java e Scala. Si è scelto di utilizzare Scala perché offre i seguenti vantaggi:
		\begin{itemize}
            \item \textbf{Completamente Object-Oriented:} A differenza di Java, Scala è completamente orientato agli oggetti. Non c'è distinizione del tipo: oggetto - tipo primitivo, ogni valore è semplicemente un oggetto.
			\item \textbf{Staticamente tipato:} \'E un linguaggio tipato staticamente, questo permette di effettuare più facilmente i test. Inoltre Scala è in grado di stabilire il tipo di un oggetto per inferenza.
            \item \textbf{Può eseguire codice Java:} Scala può eseguire codice scritto in Java. \'E dunque possibile utilizzare classi e librerie scritte in Java all'interno di programmi scritti in Scala. 
            \item \textbf{Concorrenza e distribuzione:} Ottimo supporto alla programmazione multi-threaded e distribuita, essenziale per la realizzazione di un prodotto responsive e scalabile.
			\item \textbf{Supporto alla definizione di DSL:} Scala supporta nativamente la definizione di DSL.
            \item \textbf{Supporto di Akka:} Il linguaggio supporta la libreria Akka che è richiesta dal capitolato.
		\end{itemize}
		Inoltre il Committente ha espresso esplicitamente la sua preferenza sull'utilizzo di Scala.
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.15]{immagini/ST/scala.png}
			\caption{Scala - logo}
		\end{figure}	
	\subsection{Akka}
		L'utilizzo della libreria Akka oltre ad essere reso obbligatorio dal committente, fornisce un'eccellente base su cui sviluppare un sistema basato sul modello ad attori.
        Akka permette di costruire facilmente applicazioni message-driven che siano estremamente concorrenti, distribuite e resilienti.         
        La natura distribuita e asincrona degli attori messi a disposizione da Akka soddisfa pienamente i bisogni del sistema da implementare.
	\begin{figure} [H]
			\centering
			\includegraphics[scale=0.45]{immagini/ST/Akka.png}
			\caption{Akka - logo}
		\end{figure}	
	
	
	\newpage 
	\section{Descrizione dell'architettura}
		\subsection{Metodo e formalismo di specifica}
			Nell'esposizione dell'architettura del prodotto si procederà con un approccio di tipo top-down, ovvero dal generale al particolare. \\
			Inizialmente si descriveranno le tre componenti fondamentali: Client, Server e Driver; poi le componenti più piccole al loro interno, specificando i package e le classi che li compongono. \\ \\
			Per ogni package saranno descritti brevemente il tipo, l'obiettivo e la funzione e saranno specificati eventuali figli, classi ed interazioni con altri package.
			Ogni classe sarà dotata di una breve descrizione e ne saranno specificate le responsabilità, le classi ereditate, le sottoclassi e le relazioni con altre classi. \\
			Successivamente saranno mostrati e descritti i diagrammi delle attività che coinvolgono l'utente. \\
			Infine si illustreranno degli esempi di utilizzo dei design pattern nell'architettura del sistema.
		\subsection{Architettura generale}
        	L'architettura generale del sistema è di tipo client-server. \\ \\
            Il server ha un'architettura di tipo event-driven basata sul modello ad attori ed espone delle API tramite socket TCP. \\ \\
            L'architettura del Client segue il design pattern Model-View-Controller con interfaccia da linea di comando e comunica con il server  grazie ad un driver tramite connessione TCP.
            
        \begin{figure} [H]
			\centering
			\includegraphics[scale=0.25]{Packages_Generale.png}
			\caption{Architettura generale, vista Package}
		\end{figure}
		
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.3]{ST/Legenda.png}
			\caption{Legenda}
		\end{figure}
            \subsubsection{Server}
        	Il server di \emph{Actorbase} è composto da due package principali: il package \textbf{Core} e il package \textbf{API}. \\
            Il package \textbf{Core} è a sua volta composto dal package \textbf{Actors}, contenente le classi che definiscono gli attori del sistema, e dal package \textbf{messages}, contenente i messaggi che gli attori possono inviarsi tra loro. \\
            Il package \textbf{API} contiene le classi che forniscono una comunicazione con i client esterni.
            \begin{figure} [H]
			\centering
			\includegraphics[scale=0.35]{Server/Package/serverALL.png}
			\caption{Server, vista Package}
		\end{figure}
        \subsubsection{Client}
        	L'architettura del Client seguirà il design pattern MVC:
            \begin{itemize}
				\item \textbf{Model:}
                	Il Model è la componente che si occupa di comunicare con il server usando i metodi del driver e di notificare la View quando avviene un cambiamento nel suo stato.
                \item \textbf{View:}
                	La View è la componente che interagisce con l'utente mediante interfaccia a linea di comando. L'utente può usare il DSL per interrogare il Model. La View esegue delle \emph{state query} sul model per avere le informazioni aggiornate.
                \item \textbf{Controller:}
                	Il Controller è la componente che esegue il parsing dei comandi del DSL inseriti nella View e li notifica al Model.			
			\end{itemize}
        
        \subsubsection{Driver}
        	Il Driver è una libreria, invocando i metodi della quale è possibile effettuare richieste TCP verso le API esposte dal Server.
        \begin{figure} [H]
			\centering
			\includegraphics[scale=0.35]{ST/Client/GeneraleClient.png}
        	\caption{Architettura generale Client e Driver}
		\end{figure}
            
	\newpage 
	\section{Componenti e Classi}
		\subsection{Actorbase}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.50]{Server/Package/actorbase.png}
			\caption{Componente Actorbase}
		\end{figure}
			\subsubsection{Descrizione}
				\'E il package principale del sistema. L'interazione tra i package \textbf{Server} e \textbf{Driver} definiscono una comunicazione su rete di tipo client-server. \\ Le classi definite nel package \textbf{Server} utilizzano ed estendono le classi della libreria Akka.
			\subsubsection{Package Figli}
				\begin{itemize}
					\item Actorbase.Server
					\item Actorbase.Client
					\item Actorbase.Driver
					\item Actorbase.Akka
				\end{itemize}
		\subsection{Actorbase.Server}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.50]{Server/Package/ServerLevel.png}
			\caption{Componente Actorbase.Server}
			\end{figure}
			\subsubsection{Descrizione}
				Package per la componente lato server del sistema. \'E composto dai packages \textbf{Core} ed \textbf{API} e dalla classe \emph{ActorbaseServer}.
			\subsubsection{Package Figli}
				\begin{itemize}
					\item Actorbase.Server.Core
					\item Actorbase.Server.API
				\end{itemize}
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.ActorbaseServer
			\end{itemize}
		\subsection{Actorbase.Server.API}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.70]{Server/Package/APILevel.png}
			\caption{Componente Actorbase.Server.API}
			\end{figure}
			\subsubsection{Descrizione}
				Package contenenti le classi che definiscono le API attraverso cui i client possono interfacciarsi all'istanza di un server del sistema.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.API.API
			\end{itemize}
			
		\subsection{Actorbase.Server.Core}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.55]{Server/Package/CoreLevel.png}
			\caption{Componente Actorbase.Server.Core}
			\end{figure}
			\subsubsection{Descrizione}
				Il package contiene le componenti che costituiscono il nucleo del sistema logico lato server. \'E composto da due package: \textbf{Actors} e \textbf{Messages}
			\subsubsection{Package figli}
			\begin{itemize}
				\item Actorbase.Server.Core.Actors
				\item Actorbase.Server.Core.Messages
			\end{itemize}
			
		\subsection{Actorbase.Server.Core.Actors}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.50]{Server/Package/ActorsLevel.png}
			\caption{Componente Actorbase.Server.Core.Actors}
			\end{figure}
			\subsubsection{Descrizione}
				Il package contiene le componenti che costituiscono i diversi attori definiti nel sistema. I package che lo compongono definiscono le diverse categorie degli attori.
			\subsubsection{Package figli}
			\begin{itemize}
				\item Actorbase.Server.Core.Actors.DataManagement
				\item Actorbase.Server.Core.Actors.Manager
				\item Actorbase.Server.Core.Actors.StoreFinder
			\end{itemize}
			
			\subsection{Actorbase.Server.Core.Actors.DataManagement}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.55]{Server/Package/DatamanagementLevel.png}
			\caption{Componente Actorbase.Server.Core.Actors.DataManagement}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi che rappresentano gli attori che si occupano direttamente della gestione dei dati.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Actors.DataManagement.DataManager
				\item Actorbase.Server.Core.Actors.DataManagement.WareHouseMan
				\item Actorbase.Server.Core.Actors.DataManagement.UpdateActor
				\item Actorbase.Server.Core.Actors.DataManagement.DeleteActor
				\item Actorbase.Server.Core.Actors.DataManagement.InsertActor
			\end{itemize}
			
		\subsection{Actorbase.Server.Core.Actors.Manager}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.65]{Server/Package/ManagerLevel.png}
			\caption{Componente Actorbase.Server.Core.Actors.Manager}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi che rappresentano gli attori che si occupano della gestione di altri attori e dei vincoli presenti su di essi.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Actors.Manager.Manager
			\end{itemize}
			
		\subsection{Actorbase.Server.Core.Actors.StoreFinder}
			\begin{figure} [H]
			\centering
			\includegraphics[width=\textwidth]{Server/Package/StorefinderLevel.png}
			\caption{Componente Actorbase.Server.Core.Actors.StoreFinder}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi che rappresentano gli attori che si occupano dell'indicizzazione degli altri attori presenti e del corretto instradamento dei messaggi.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Actors.StoreFinder.StoreFinder
				\item Actorbase.Server.Core.Actors.StoreFinder.Main
				\item Actorbase.Server.Core.Actors.StoreFinder.HTTPBuilder
				\item Actorbase.Server.Core.Actors.StoreFinder.MessageBuilder
			\end{itemize}
			\subsubsection{Interfacce}
			\begin{itemize}
				\item Actorbase.Server.Core.Actors.StoreFinder.IndexesHandler
			\end{itemize}
		
		\subsection{Actorbase.Server.Core.Messages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.55]{Server/Package/MessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le componenti che rappresentano i messaggi che i diversi attori del sistema possono inviarsi tra loro.
			\subsubsection{Package Figli}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.ConfigurationMessages
				\item Actorbase.Server.Core.Messages.PermissionMessages
				\item Actorbase.Server.Core.Messages.LinkActorsMessages
				\item Actorbase.Server.Core.Messages.MainOperationMessages
				\item Actorbase.Server.Core.Messages.DataManagementMessages
				\item Actorbase.Server.Core.Messages.ChangeInterfaceMessages
			\end{itemize}
			
			\subsection{Actorbase.Server.Core.Messages.ConfigurationMessages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.55]{Server/Package/ConfigurationMessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages.ConfigurationMessages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi e le interfacce che rappresentano i messaggi relativi ad operazioni di configurazione delle impostazioni del server.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.MaxStoreFinderMsg
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.MaxNinjaMsg
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.MaxWarehousemanMsg
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.UpdatePropertiesMsg
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.ReadPropertiesMsg
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.SaveStateMsg
			\end{itemize}
			\subsubsection{Interfacce}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.MainConfigurationMessage
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.StoreFinderConfigurationMessage
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.ManagerConfigurationMessage
				\item Actorbase.Server.Core.Messages.ConfigurationMessages.DataManagerConfigurationMessage
			\end{itemize}
			
			\subsection{Actorbase.Server.Core.Messages.PermissionMessages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.65]{Server/Package/PermissionsMessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages.PermissionMessages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le interfacce che rappresentano i diversi gradi di permesso che un'operazione richiede. Un'operazione può infatti richiedere i permessi di lettura, scrittura o nessun permesso. Ogni messaggio relativo ad un'operazione richiedibile da un client estende una di queste interfacce.
			\subsubsection{Interfacce}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.PermissionMessages.PermissionsNotRequiredInterface
				\item Actorbase.Server.Core.Messages.PermissionMessages.ReadPermissionsInterface
				\item Actorbase.Server.Core.Messages.PermissionMessages.WritePermissionsInterface
			\end{itemize}
			
			\subsection{Actorbase.Server.Core.Messages.LinkActorsMessages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.65]{Server/Package/LinkActorsMessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages.LinkActorsMessages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi che rappresentano i messaggi relativi alla gestione dei collegamenti tra diversi attori.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.LinkActorsMessages.UpdateStoreKeeperMsg
				\item Actorbase.Server.Core.Messages.LinkActorsMessages.InsertStoreKeeperMsg
			\end{itemize}
			
			\subsection{Actorbase.Server.Core.Messages.MainOperationMessages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.55]{Server/Package/MainOperationsMessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages.MainOperationMessages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi e le interfacce che rappresentano i messaggi relativi ad operazioni che non richiedono l'invio di ulteriori messaggi ad attori che gestiscono i dati direttamente.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.MainOperationMessages.ShowDBMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.ShowMapMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.CreateDBMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.CreateMapMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.RenameDBMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.RenameMapMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.DeleteDBMsg
				\item Actorbase.Server.Core.Messages.MainOperationMessages.DeleteMapMsg
			\end{itemize}
			\subsubsection{Interfacce}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.MainOperationMessages.MainOperationMessage
			\end{itemize}
			
		\subsection{Actorbase.Server.Core.Messages.DataManagerOperationMessages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.50]{Server/Package/DatamanagementMessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages.DataManagerOperationMessages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi e le interfacce che rappresentano i messaggi relativi ad operazioni che richiedono l'invio di tali messaggi anche ad attori che gestiscono i dati direttamente.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.DataManagerOperationMessages.KeysMsg
				\item Actorbase.Server.Core.Messages.DataManagerOperationMessages.FindMsg
				\item Actorbase.Server.Core.Messages.DataManagerOperationMessages.InsertMsg
				\item Actorbase.Server.Core.Messages.DataManagerOperationMessages.UpdateMsg
				\item Actorbase.Server.Core.Messages.DataManagerOperationMessages.RemoveMsg
			\end{itemize}
			\subsubsection{Interfacce}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.DataManagerOperationMessages.DataManagerOperationMessage
			\end{itemize}
			
			\subsection{Actorbase.Server.Core.Messages.ChangeInterfaceMessages}
			\begin{figure} [H]
			\centering
			\includegraphics[scale=0.65]{Server/Package/ChangeInterfaceMessagesLevel.png}
			\caption{Componente Actorbase.Server.Core.Messages.ChangeInterfaceMessages}
			\end{figure}
			\subsubsection{Descrizione}
				All'interno di questo package sono definite le classi e le interfacce che rappresentano i messaggi inviabili per effettuare operazioni di cambio interfaccia per gli attori che supportano tale funzionalità.
			\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Server.Core.Messages.ChangeInterfaceMessages.BecomeNinjaMsg
				\item Actorbase.Server.Core.Messages.ChangeInterfaceMessages.BecomeStoreKeeperMsg
			\end{itemize}
			
			
					\subsection{Actorbase.Driver}
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.5]{ST/Client/DriverSemplificato.png}
        	\caption{Componente Actorbase.Driver}
		\end{figure}
		
		\subsubsection{Descrizione}
			Package per la componente Driver del sistema. Per la gestione dei comandi implementa il Design Pattern Command.
			
		\subsubsection{Package Figli}
			\begin{itemize}
				\item Actorbase.Driver.Components
				\item Actorbase.Driver.Exceptions
			\end{itemize}
			
		\subsubsection{Classi}
			\begin{itemize}
				\item Actorbase.Driver.Driver
				\item Actorbase.Driver.Connection
			\end{itemize}
			
		\subsubsection{Interfacce}
			\begin{itemize}
				\item Actorbase.Driver.DriverInterface
			\end{itemize}
		
		\subsection{Actorbase.Driver.Connection}
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.5]{ST/Client/ConnectionClasse.png}
        	\caption{Classe Actorbase.Driver.Connection}
		\end{figure}
		
		\subsubsection{Descrizione}
			Classe \emph{singleton} che gestisce la comunicazione del Driver con il Server. Svolge il ruolo di \emph{Receiver}.
		\subsubsection{Utilizzo}
			Viene usata per aprire e chiudere la connessione con il Server, inviare i messaggi e per generare la prima parte del comando per le API.
		\subsubsection{Relazione con altre classi}
			\begin{itemize}
				\item \textbf{Actorbase.Driver.Commands.ServerCommand}: Relazione entrante, invio comando al Server.
				\item \textbf{Actorbase.Driver.Exception}: Relazione uscente, creazione di eccezioni.
			\end{itemize}
		
		\subsection{Actorbase.Driver.Driver}
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.5]{ST/Client/DriverClasse.png}
        	\caption{Classe Actorbase.Driver.Driver e interfaccia Actorbase.Driver.DriverInterface}
		\end{figure}
		
		\subsubsection{Descrizione}
			Classe che gestisce la comunicazione mediante API. Svolge il ruolo di \emph{Invoker}.
		\subsubsection{Utilizzo}
			Espone i metodi per codifica e decodifica dei comandi delle API. Inoltre mantiene le informazioni relative ad eventuali DataBase o Mappe selezionate.
		\subsubsection{Interfacce Estese}
			Actorbase.Driver.DriverInterface
		\subsubsection{Relazioni con altre classi}
		\begin{itemize}
			\item \textbf{Actorbase.Driver.Commands}: Relazione uscente, utilizzo del metodo Execute.
			\item \textbf{Actorbase.Driver.Exceptions}: Relazione uscente, creazione di eccezioni.
		\end{itemize}
		
		
	\subsection{Actorbase.Driver.Commands}
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.40]{ST/Client/CommandsClasses.png}
        	\caption{Package Actorbase.Driver.Commands}
		\end{figure}
		\subsubsection{Descrizione}
			Package che contiene i la gerarchia di comandi dell'interfaccia \emph{Command}. Ognuno di essi rappresenta astrattamente una operazione che deve essere svolta a livello del Server. Sono presenti due gerarchie di interfacce, una per la tipologia di comandi (lato client, lato server, lettura, scrittura) e l'altra per la tipologia di "preselezioni" necessarie per eseguire il comando (DataBase selezionato, Mappa selezionata).
			
		\subsubsection{Gerarchia classi ed interfacce}
		Al fine di rendere maggiormente comprensibile la descrizione di questo Package verrà descritta di seguito la gerarchia delle classi ed interfacce in esso contenuta.\\
		\textbf{Actorbase.Driver.Commands.ParsedCommand}
			\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un generico comando che il Driver sa trattare.
				\item \textbf{Interfacce Figle:} Actorbase.Driver.Commands.ServerCommand
			\end{itemize}

		
		\textbf{Actorbase.Driver.Commands.ServerCommand}
			\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un comando lato Server.
				\item \textbf{Interfacce Estese:} Actorbase.Driver.Commands.ParsedCommand
				\item \textbf{Interfacce Figlie:}
					\begin{itemize}
						\item Actorbase.Driver.Commands.ReadCommand
						\item Actorbase.Driver.Commands.WriteCommand
						\item Actorbase.Driver.Commands.ConnectionCommand
					\end{itemize}
			\end{itemize}
		
		\textbf{Actorbase.Driver.Commands.ReadCommand}
		\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un comando per cui sono necessari i permessi di lettura sulla tabella selezionata
				\item \textbf{Interfacce Estese:} Actorbase.Driver.Commands.ServerCommand
				\item \textbf{Classi Figlie:}
					\begin{itemize}
						\item \textbf{Actorbase.Driver.Commands.KeysCommand}:
							Classe concreta che rappresenta il comando per mostrare la lista delle chiavi nella mappa selezionata.
						\item \textbf{Actorbase.Driver.Commands.SelectCommand}:
							Classe concreta che rappresenta il comando per selezionare il valore di una chiave nella mappa selezionata.
						\item \textbf{Actorbase.Driver.Commands.ShowBDCommand}:
							Classe concreta che rappresenta il comando per mostrare l'elenco dei DataBase di cui si hanno permessi di lettura.
						\item \textbf{Actorbase.Driver.Commands.SelectDBCommand}:
							Classe concreta che rappresenta il comando per selezionare un determinato DataBase.
						\item \textbf{Actorbase.Driver.Commands.ShowMapCommand}:
							Classe concreta che rappresenta il comando per mostrare la lista delle mappe nel DataBase selezionato.
						\item \textbf{Actorbase.Driver.Commands.SelectMapCommand}:
							Classe concreta che rappresenta il comando per selezionatare una determinata mappa.
					\end{itemize}
			\end{itemize}

		\textbf{Actorbase.Driver.Commands.WriteCommand}
		\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un comando per cui sono necessari i permessi di scrittura sulla tabella selezionata
				\item \textbf{Interfacce Estese:} Actorbase.Driver.Commands.ServerCommand
				\item \textbf{Classi Figlie:}
					\begin{itemize}
						\item \textbf{Actorbase.Driver.Commands.InsertCommand}:
							Classe concreta che rappresenta il comando per inserire una coppia chiave-valore nella mappa selezionata.
						\item \textbf{Actorbase.Driver.Commands.UpdateCommand}:
							Classe concreta che rappresenta il comando per aggiornare il valore di una chiave nella mappa selezionata.
						\item \textbf{Actorbase.Driver.Commands.AppendCommand}:
							Classe concreta che rappresenta il comando per appendere in coda al valore di una chiave nella mappa selezionata.
						\item \textbf{Actorbase.Driver.Commands.RemoveCommand}:
							Classe concreta che rappresenta il comando per rimuovere una coppia chiave-valore dalla mappa selezionata.
						\item \textbf{Actorbase.Driver.Commands.CreateMapCommand}:
							Classe concreta che rappresenta il comando per creare una nuova mappa nel DataBase selezionato.
						\item \textbf{Actorbase.Driver.Commands.DeleteMapCommand}:
							Classe concreta che rappresenta il comando per eliminare una mappa nel DataBase selezionato.
						\item \textbf{Actorbase.Driver.Commands.RenameMapCommand}:
							Classe concreta che rappresenta il comando per rinominare una mappa nel DataBase selezionato.
						\item \textbf{Actorbase.Driver.Commands.CreateDBCommand}:
							Classe concreta che rappresenta il comando per creare un nuovo DataBase.
						\item \textbf{Actorbase.Driver.Commands.DeleteDBCommand}:
							Classe concreta che rappresenta il comando per rimuovere un DataBase.
						\item \textbf{Actorbase.Driver.Commands.RenameDBCommand}:
							Classe concreta che rappresenta il comando per rinominare un DataBase.
					\end{itemize}
			\end{itemize}
		
		\textbf{Actorbase.Driver.Commands.ConnectionCommand}
		\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un comando di connessione o disconnessione dal Server.
				\item \textbf{Interfacce Estese:} Actorbase.Driver.Commands.ServerCommand
				\item \textbf{Classi Figlie:}
					\begin{itemize}
						\item \textbf{Actorbase.Driver.Commands.ConnectCommand}:
							Classe concreta che rappresenta il comando per la connessione al server.
						\item \textbf{Actorbase.Driver.Commands.DisconnectCommand}:
							Classe concreta che rappresenta il comando per la disconnessione dal server.
					\end{itemize}
			\end{itemize}
		
		\textbf{Actorbase.Driver.Commands.DBSelectedCommand}
		\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un generico comando che per cui è necessario avere un DataBase selezionato.
				\item \textbf{Classi Figlie:}
					\begin{itemize}
						\item Actorbase.Driver.Commands.ShowMapCommand
						\item Actorbase.Driver.Commands.SelectMapCommand
						\item Actorbase.Driver.Commands.CreateCommand
						\item Actorbase.Driver.Commands.DeleteCommand
						\item Actorbase.Driver.Commands.RenameCommand
					\end{itemize}
			\end{itemize}


		\textbf{Actorbase.Driver.Commands.MapSelectedCommand}
		\begin{itemize}
				\item \textbf{Descrizione:} Interfaccia base che rappresenta un generico comando che per cui è necessario avere una mappa selezionata.
				\item \textbf{Interfacce Estese:} Actorbase.Driver.Commands.DBSelectedCommand
				\item \textbf{Classi Figlie:}
					\begin{itemize}
						\item Actorbase.Driver.Commands.KeysCommand
						\item Actorbase.Driver.Commands.SelectCommand
						\item Actorbase.Driver.Commands.InsertCommand
						\item Actorbase.Driver.Commands.UpdateCommand
						\item Actorbase.Driver.Commands.AppendCommand
						\item Actorbase.Driver.Commands.RemoveCommand
					\end{itemize}
			\end{itemize}
	
	\newpage 
	\section{Diagrammi delle attività}
		Segue la descrizione dei diagrammi delle attività che mostrano le possibili interazioni dell'utente con Actorbase. Il diagramma iniziale illustrerà le attività possibili che saranno successivamente mostrate in sotto diagrammi specifici, queste attività sono segnate nel diagramma principale con un fork.
		\subsubsection{Diagramma attività principale}
		
		\begin{figure} [H]
			\centering
			\includegraphics[scale=0.6]{ST/client/diagramma-attivita-generale.png}
			\caption{Diagramma attività principale}
		\end{figure}
			Dopo aver avviato il client l'utente può svolgere tre tipi di operazione: connettersi ad un server, chiudere l'applicativo o svolgere un operazione offline. Se sceglie di connettersi può sempre chiudere l'applicativo e svolgere operazioni che non necessitano di essere connessi al server, può in più disconnettersi o svolgere operazioni sul server, non potrà però più connettersi ad un server finché non effettua la disconnessione dal sever corrente.
			
		\subsubsection{Offline Operation}
			\begin{figure} [H]
				\centering
				\includegraphics[scale=0.6]{ST/client/diagramma-offline-operation.png}
				\caption{Diagramma attività operazioni offline}
			\end{figure}
				L'utente sceglie se chiedere un aiuto generale, o riguardante un comando specifico, nel primo caso è sufficiente che digiti il comando di aiuto e lo confermi, altrimenti dovrà successivamente scrivere il comando del quale vuole avere chiarimenti e poi confermare.
		\subsubsection{Connect to Server}
			\begin{figure} [H]
				\centering
				\includegraphics[scale=0.6]{ST/client/diagramma-Connect-to-Server.png}
				\caption{Diagramma attività connessione ad un server}
			\end{figure}
				Per effettuare una connessione l'utente dovrà digitare il commando di connessione e successivamente fornire i dati per la connessione, nello specifico: l'indirizzo IP al quale ci si vuole connettere, il nome utente e la password. Dopo di che è sufficiente che confermi il comando.
		\subsubsection{Online Operation}
			\begin{figure} [H]
				\centering
				\includegraphics[scale=0.4]{ST/client/diagramma-Online-Operation.png}
				\caption{Diagramma attività operazioni online}
			\end{figure}
				L'utente sceglie che tipo di operazione vuole effettuare, se vuole effettuare un' operazione di rinomina su un database o una mappa è sufficiente che fornisca il comando di rinomina, il vecchio e il nuovo nome e che poi confermi l'operazione; se vuole effettuare un' operazione di selezione o di creazione o di cancellazione sia di un database che di una mappa, deve digitare il comando corretto e successivamente il nome del database o della mappa sulla quale vuole effettuare l'operazione dopo di che è sufficiente che confermi il comando; se vuole effettuare un' operazione di rimozione o selezione di un dato è necessario che digiti il comando desiderato, digiti la chiave completa e che confermi l'operazione; se vuole effettuare un inserimento di un dato o un aggiornamento di un dato deve inserire il comando corretto, digitare la chiave completa e confermare l'operazione.
	\newpage 
	\section{Design pattern}
	
	\newpage 
	\section{Stime di fattibilità e di bisogno di risorse}
	
		L'architettura definita fino a questo punto è sufficiente per fornire una stima della fattibilità del prodotto e delle risorse richieste per la realizzazione. \\
	Il gruppo inizialmente non aveva conoscenze sufficienti per stimare in modo appropriato la complessità dell'implementazione di un database basato sulla logica ad attori. Grazie al livello di dettaglio raggiunto sono stati fugati molti dei dubbi e delle incertezze a riguardo, confermando le previsioni sull'esito positivo del progetto. \\
	Sono state inoltre individuate con chiarezza le risorse tecnologiche che verranno utilizzate:
	\begin{itemize}
		\item Akka: libreria per modello ad attori.
		\item IntelliJ: framework per la stesura del codice.
		\item JVM: piattaforma per il funzionamento di Scala.
	\end{itemize}
	Il gruppo in contemporanea si è dedicato allo studio delle nuove tecnologie raggiungendo un buon livello di conoscenza. L'insieme di queste risorse potrà garantire la realizzazione di tutte le componenti dell'architettura.
	
	\newpage 
	\section{Tracciamento}
		\subsection{Tracciamento componenti-requisiti}
		\subsection{Tracciamento requisiti-componenti}
		
	\newpage 
	\section{Appendice}
	\subsection{Descrizione Desing Pattern}
	Segue, per ogni Desing Pattern utilizzato, la descrizione dello scopo, motivazione e applicabilità.
	\subsubsection{Event-driven}
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.65]{immagini/ST/schemaevent-driven.jpg}
					\caption{Diagramma del Desing Pattern Event-driven}
				\end{figure}
            \begin{itemize}
				\item \textbf{Scopo:}
					Produrre applicazioni molto scalabili e processare eventi asincroni disaccoppiati.
                \item \textbf{Motivazione:} Gestire le richieste che vengono volte all' applicativo tramite eventi processati in modo asincrono.
                \item \textbf{Applicabilità:}
                	Gestione di eventi attraverso l'utilizzo di un mediatore e elaboratori di eventi		
			\end{itemize}
	\subsubsection{MVC}
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.65]{immagini/ST/schemaMVC.jpg}
					\caption{Diagramma del Desing Pattern MVC}
				\end{figure}
            \begin{itemize}
				\item \textbf{Scopo:}
					Disaccoppiamento delle seguenti componenti:
					\begin{itemize}
						\item Model regole di accesso e dati di business
						\item View rappresentazione grafica
						\item Controller reazioni della UI agli input utente
					\end{itemize}
                \item \textbf{Motivazione:}
                	Lo scopo di molti applicativi è di recuperare dati e mostrarli all'Utente. Si è visto che la migliore soluzione di questo scopo è dividere la modellazione del dominio, la presentazione e le reazioni basate sugli input degli utenti i tre classi separate, esistono vari desing pattern che svolgono questa separazione, uno di questi è MVC; 
                \item \textbf{Applicabilità:}
					\begin{itemize}
						\item Applicazioni che devono presentare attraverso una UI un insieme di informazioni
						\item Le persone responsabili dello sviluppo hanno compentenze differenti
					\end{itemize}
                	 		
			\end{itemize}
	\subsubsection{Command}
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.65]{immagini/ST/schemacomand.jpg}
					\caption{Diagramma del Desing Pattern Command}
				\end{figure}
            \begin{itemize}
				\item \textbf{Scopo:}Incapsulare una richiesta in un oggetto, cosicché i client siano indipendenti dalle richieste 
                \item \textbf{Motivazione:}
                Risolvere la necessità di gestire richieste di sui non si conoscono i particolari, tramite una classe astratta, Command, che definisce un interfaccia per eseguire la richiesta
                \item \textbf{Applicabilità:}
					\begin{itemize}
						\item Parametrizzazione di oggetti sull'azione da eseguire
						\item Specificare, accordare ed eseguire richieste molteplici volte
						\item Supporto ad operazioni di Undo e Redo
						\item Supporto a transazione, un comando equivale ad una operazione atomica
					\end{itemize}		
			\end{itemize}
				
	\subsubsection{Singleton}
				\begin{figure}[H]
					\centering
					\includegraphics[scale=0.65]{immagini/ST/Singleton.png}
					\caption{Diagramma del Desing Pattern Command}
				\end{figure}
		\begin{itemize}
			\item \textbf{Scopo:} Assicurare che una classe abbia una sola istanza con un unico punto di accesso globale.
			\item \textbf{Motivazione:}È necessario assicurare che esista una sola istanza di alcune classi. Una classe Singleton ha la responsabilità sulle proprie istanze, in modo che nessuna altra istanza possa essere creata, e fornisce un punto di accesso unico.
			\item \textbf{Applicabilità:}
			\begin{itemize}
				\item Deve esistere una ed una sola istanza di una classe in tutta l'applicazione, accessibile dai client in modo noto.
				\item L'istanza deve essere estendibile con ereditarietà, consentendo ai client di non modificare il proprio codice.
			\end{itemize}
		\end{itemize}
		
		
	\subsubsection{Singleton}
		\begin{itemize}
			\item \textbf{Scopo:} Assicurare che una classe abbia una sola istanza con un unico punto di accesso globale.
			\item \textbf{Motivazione:}È necessario assicurare che esista una sola istanza di alcune classi. Una classe Singleton ha la responsabilità sulle proprie istanze, in modo che nessuna altra istanza possa essere creata, e fornisce un punto di accesso unico.
			\item \textbf{Applicabilità:}
			\begin{itemize}
				\item Deve esistere una ed una sola istanza di una classe in tutta l'applicazione, accessibile dai client in modo noto.
				\item L'istanza deve essere estendibile con ereditarietà, consentendo ai client di non modificare il proprio codice.
			\end{itemize}
		\end{itemize}
	
	\cleardoublepage
	\addcontentsline{toc}{section}{\listfigurename}
	\listoffigures
	
	\cleardoublepage
	\addcontentsline{toc}{section}{\listtablename}
	\listoftables
		
\end{document}